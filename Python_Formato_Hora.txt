import pandas as pd
import numpy as np
from datetime import datetime
import os

def limpiar_base_accidentalidad(ruta_archivo):
    """
    Funci√≥n completa para limpiar la base de datos de accidentalidad
    """
    
    # Verificar si el archivo existe
    if not os.path.exists(ruta_archivo):
        print(f"Error: El archivo {ruta_archivo} no existe")
        return None
    
    try:
        # 1. CARGAR LOS DATOS
        print("Cargando datos desde Excel...")
        df = pd.read_excel(ruta_archivo)
        print(f"‚úì Datos cargados: {df.shape[0]} filas, {df.shape[1]} columnas")
        
        # 2. INSPECCI√ìN INICIAL
        print("\n2. Inspecci√≥n inicial de datos:")
        print(f"Columnas: {list(df.columns)}")
        print(f"Tipos de datos:\n{df.dtypes}")
        print(f"Valores nulos por columna:\n{df.isnull().sum()}")
        
        # 3. LIMPIEZA DE COLUMNAS EXISTENTES
        print("\n3. Limpiando columnas existentes...")
        
        # Limpiar espacios en blanco en todas las columnas de texto
        columnas_texto = ['D√çA DE LA SEMANA', 'CLASE', 'DIRECCI√ìN', 'GRAVEDAD_DA√ëOS', 'BARRIO', 'COMUNA']
        for col in columnas_texto:
            if col in df.columns:
                df[col] = df[col].astype(str).str.strip()
        
        # Convertir FECHA a formato datetime
        if 'FECHA' in df.columns:
            df['FECHA'] = pd.to_datetime(df['FECHA'], dayfirst=True, errors='coerce')
            print(f"‚úì Fecha convertida a formato datetime")
        
        # Limpiar y estandarizar HORA
        if 'HORA' in df.columns:
            # Primero convertir a string y limpiar
            df['HORA'] = df['HORA'].astype(str).str.strip()
            
            # Funci√≥n para convertir hora
            def convertir_hora(hora_str):
                try:
                    # Si ya es un objeto tiempo o datetime
                    if isinstance(hora_str, (datetime, pd.Timestamp)):
                        return hora_str.time()
                    
                    # Si est√° en formato HH:MM
                    if ':' in hora_str and len(hora_str) <= 5:
                        return pd.to_datetime(hora_str, format='%H:%M').time()
                    
                    # Si tiene segundos u otro formato
                    return pd.to_datetime(hora_str, errors='coerce').time()
                    
                except:
                    return None
            
            df['HORA_LIMPIA'] = df['HORA'].apply(convertir_hora)
            df['HORA_STR'] = df['HORA_LIMPIA'].apply(lambda x: x.strftime('%H:%M') if x else None)
            print(f"‚úì Hora limpiada y estandarizada")
        
        # Estandarizar texto en columnas categ√≥ricas
        if 'D√çA DE LA SEMANA' in df.columns:
            df['D√çA DE LA SEMANA'] = df['D√çA DE LA SEMANA'].str.upper().str.strip()
        
        if 'CLASE' in df.columns:
            df['CLASE'] = df['CLASE'].str.upper().str.strip()
        
        if 'GRAVEDAD_DA√ëOS' in df.columns:
            df['GRAVEDAD_DA√ëOS'] = df['GRAVEDAD_DA√ëOS'].str.upper().str.strip()
        
        if 'BARRIO' in df.columns:
            df['BARRIO'] = df['BARRIO'].str.upper().str.strip()
        
        if 'COMUNA' in df.columns:
            df['COMUNA'] = df['COMUNA'].str.upper().str.strip()
        
        # 4. CREAR VARIABLES DERIVADAS
        print("\n4. Creando variables derivadas...")
        
        if 'FECHA' in df.columns:
            df['MES'] = df['FECHA'].dt.month
            df['DIA_SEMANA_NUM'] = df['FECHA'].dt.dayofweek
            df['DIA_MES'] = df['FECHA'].dt.day
        
        if 'HORA_LIMPIA' in df.columns:
            df['HORA_NUM'] = df['HORA_LIMPIA'].apply(lambda x: x.hour if x else None)
            df['FRANJA_HORARIA'] = df['HORA_NUM'].apply(lambda x: 
                'MADRUGADA (0-6)' if 0 <= x < 6 else
                'MA√ëANA (6-12)' if 6 <= x < 12 else
                'TARDE (12-18)' if 12 <= x < 18 else
                'NOCHE (18-24)' if 18 <= x <= 24 else 'DESCONOCIDO'
            )
        
        # 5. IDENTIFICAR Y MANEJAR VALORES NULOS/DUPLICADOS
        print("\n5. Manejo de valores nulos y duplicados...")
        
        # Contar valores nulos antes
        nulos_antes = df.isnull().sum().sum()
        print(f"Valores nulos totales antes: {nulos_antes}")
        
        # Eliminar filas completamente vac√≠as
        df = df.dropna(how='all')
        
        # Eliminar duplicados exactos
        duplicados = df.duplicated().sum()
        if duplicados > 0:
            df = df.drop_duplicates()
            print(f"‚úì Eliminados {duplicados} registros duplicados")
        
        # 6. VALIDACI√ìN Y CONTROL DE CALIDAD
        print("\n6. Validaci√≥n final de datos...")
        
        # Verificar valores √∫nicos en columnas categ√≥ricas clave
        print("Valores √∫nicos en CLASE:", df['CLASE'].unique())
        print("Valores √∫nicos en GRAVEDAD_DA√ëOS:", df['GRAVEDAD_DA√ëOS'].unique())
        
        # Verificar rangos de fechas
        if 'FECHA' in df.columns:
            print(f"Rango de fechas: {df['FECHA'].min()} a {df['FECHA'].max()}")
        
        # Verificar rangos de horas
        if 'HORA_NUM' in df.columns:
            print(f"Rango de horas: {df['HORA_NUM'].min()} a {df['HORA_NUM'].max()}")
        
        # 7. RESUMEN FINAL
        print("\n" + "="*50)
        print("RESUMEN FINAL DE LA LIMPIEZA:")
        print("="*50)
        print(f"‚úì Registros finales: {df.shape[0]}")
        print(f"‚úì Columnas finales: {df.shape[1]}")
        print(f"‚úì Valores nulos restantes: {df.isnull().sum().sum()}")
        print(f"‚úì Columnas creadas: {[col for col in df.columns if col not in ['FECHA', 'HORA', 'D√çA DE LA SEMANA', 'CLASE', 'DIRECCI√ìN', 'GRAVEDAD_DA√ëOS', 'BARRIO', 'COMUNA']]}")
        
        return df
        
    except Exception as e:
        print(f"Error durante la limpieza: {str(e)}")
        return None

def guardar_datos_limpios(df, ruta_salida):
    """
    Guardar los datos limpios en un nuevo archivo Excel
    """
    try:
        df.to_excel(ruta_salida, index=False)
        print(f"\n‚úì Datos limpios guardados en: {ruta_salida}")
        return True
    except Exception as e:
        print(f"Error al guardar: {str(e)}")
        return False

# EJECUCI√ìN PRINCIPAL
if __name__ == "__main__":
    # Configurar rutas
    ruta_entrada = r"C:\Users\Jonathan\Desktop\Analisis_Datos\Proyecto\Proyecto_Accidentalidad.xlsx"
    ruta_salida = r"C:\Users\Jonathan\Desktop\Analisis_Datos\Proyecto\Proyecto_Accidentalidad_LIMPIO.xlsx"
    
    print("INICIANDO PROCESO DE LIMPIEZA DE DATOS")
    print("="*60)
    
    # Ejecutar limpieza
    df_limpio = limpiar_base_accidentalidad(ruta_entrada)
    
    if df_limpio is not None:
        # Mostrar vista previa de los datos limpios
        print("\nVISTA PREVIA DE DATOS LIMPIOS:")
        print(df_limpio.head())
        
        # Guardar datos limpios
        if guardar_datos_limpios(df_limpio, ruta_salida):
            print("\nüéâ ¬°PROCESO COMPLETADO EXITOSAMENTE! üéâ")
            print("\nArchivos generados:")
            print(f"1. Datos originales: {ruta_entrada}")
            print(f"2. Datos limpios: {ruta_salida}")
            
            # Informaci√≥n adicional para el an√°lisis
            print("\nPR√ìXIMOS PASOS PARA EL AN√ÅLISIS:")
            print("1. An√°lisis descriptivo b√°sico")
            print("2. Visualizaci√≥n de patrones temporales")
            print("3. An√°lisis por tipo de accidente y gravedad")
            print("4. Identificaci√≥n de zonas cr√≠ticas")
        else:
            print("‚ùå Error al guardar los datos limpios")
    else:
        print("‚ùå No se pudo completar la limpieza de datos")
def analisis_exploratorio(df):
    """
    An√°lisis exploratorio b√°sico de los datos limpios
    """
    print("\n" + "="*60)
    print("AN√ÅLISIS EXPLORATORIO INICIAL")
    print("="*60)
    
    # 1. Estad√≠sticas b√°sicas
    print("1. ESTAD√çSTICAS B√ÅSICAS:")
    print(f"Total de accidentes: {len(df)}")
    print(f"Per√≠odo analizado: {df['FECHA'].min().strftime('%d/%m/%Y')} - {df['FECHA'].max().strftime('%d/%m/%Y')}")
    
    # 2. Distribuci√≥n por gravedad
    print("\n2. DISTRIBUCI√ìN POR GRAVEDAD:")
    distrib_gravedad = df['GRAVEDAD_DA√ëOS'].value_counts()
    for gravedad, cantidad in distrib_gravedad.items():
        porcentaje = (cantidad / len(df)) * 100
        print(f"  {gravedad}: {cantidad} ({porcentaje:.1f}%)")
    
    # 3. Tipos de accidente m√°s comunes
    print("\n3. TIPOS DE ACCIDENTE M√ÅS COMUNES:")
    distrib_clase = df['CLASE'].value_counts().head(5)
    for clase, cantidad in distrib_clase.items():
        porcentaje = (cantidad / len(df)) * 100
        print(f"  {clase}: {cantidad} ({porcentaje:.1f}%)")
    
    # 4. Comunas con m√°s accidentes
    print("\n4. COMUNAS CON M√ÅS ACCIDENTES:")
    distrib_comuna = df['COMUNA'].value_counts().head(5)
    for comuna, cantidad in distrib_comuna.items():
        porcentaje = (cantidad / len(df)) * 100
        print(f"  {comuna}: {cantidad} ({porcentaje:.1f}%)")
    
    # 5. Distribuci√≥n por franja horaria
    print("\n5. DISTRIBUCI√ìN POR FRANJA HORARIA:")
    if 'FRANJA_HORARIA' in df.columns:
        distrib_horaria = df['FRANJA_HORARIA'].value_counts()
        for franja, cantidad in distrib_horaria.items():
            porcentaje = (cantidad / len(df)) * 100
            print(f"  {franja}: {cantidad} ({porcentaje:.1f}%)")

# Ejecutar an√°lisis exploratorio despu√©s de la limpieza
if df_limpio is not None:
    analisis_exploratorio(df_limpio)
